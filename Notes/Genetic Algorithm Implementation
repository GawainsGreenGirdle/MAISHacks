Placing Dungeon Objects and Creatures via Genetic Algorithm

GA & AI:
The GA is a classic AI technique in the category of evolutionary algorithms.
The system starts with random solutions (dungeon arrangements).
A fitness function measures how well each layout matches the rules/constaints of object placements (no overlaps, logical spacing, windows only on walls, paintings placed realistically).
It evolves the population and the best layouts are selected.
New layouts are generated to optimize dungeon arrangement. Two layouts can "reproduce" by crossover, mixing randomly their traits to produce an "offspring". 
Layouts are also indidvidually mutated to generate new possibilities.
Therefore, across generations, the population improves autonomously, with adaptive improvement through optimization and learning-like behavior.

Implementation:
The script generates object placements inside rooms generated by the BSP (binary space partitioning) algorithm implementation in BSPDungeonGeneration.py .
Object placement in a dungeon can be formulated as a constraint satisfaction problem, where object type is constrained to specific rules of placement. For instance, windows and paintings should be on walls (edges).
The genetic algorithm (GA) randomly generates possible object placement combinations inside rooms. 
GA evaluates dungeon arrangements relative to the overall number of correct object placements (dungeon arrangements that have less object placement violations are considered more favorable solutions).
The GA will search for the best possible arrangement with optimally minimum placement erros.

Input Data Loading:
Data read from RoomsAndObjects_clean.csv. Rows describes a room type, objects that must be placed there (Has), placement rules (Corner, WallAdjacent, CenterAxis), and possible creatures.
JSON-like list columns are parsed into lists.
Room rows become a structured dictionaries inside rooms_data.

BSP Geometry:
GA is applied to a set of rooms produced by the BSP dungeon generator.
The BSP rooms are each represented by their 4 corner coordinates.

Individual Generation:
An individual in the population represents one possible dungeon arrangement.
Function make_individual() creates a random, constraint-respecting layout for every room.

Fitness Evaluation:
Function fitness() evaluates layouts based on:
Overlap penalty: objects can’t occupy the same coordinates.
Mutual exclusivity penalty: objects that can’t coexist (defined in CSV) reduce fitness.
Coverage reward: layouts that successfully place all expected objects and creatures score higher.

GA Cycle:
GA iterates over multiple generations:
Selection: Keeps the top-performing individuals.
Crossover: Mixes object placements between two parents to create new offspring.
Mutation: Randomly repositions some objects (respecting constraints).

After all generations, the best individual (highest fitness) is chosen.

The genetic algorithm runs for 50 generations by default, each generation produces 50 individuals (layouts).
For longer and more thorough search, with greater possibility of the best dungeon arrangements, increase these thresholds.
Each generation keeps the top 10% indidviduaLS (ELITISM = 0.1) and creates 45 new individuals with crossover and mutation.

Output:
The script returns or prints the best object layout.
Optionally visualized (in main.py) with Matplotlib to show room outlines and object locations.
